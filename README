# This is a program that shows the possibilities of all the combinations in the game Blood of the Clocktower TB. 
It tests all the combinations, and if the combination does not make sense, it will move on to the next combination and print the ones that does.

This solver assumes all good players tell the truth and all evil players give arbitrary information.

All roles logic (All ability will return True(if info make senses) or False(if info does not make sense)
Washerwoman: 
  Input:
    target1(int): position of first player based on the info
    target2(int): position of second player based on the info
    role(str): role name got by the info
    role_info(list): the combinations currently being tested
  Logic:
    Either player 1 is the given Townsfolk role or registers as good (Spy), or
    player 2 is the given Townsfolk role or registers as good (Spy)

Librarian:
  Input:
    zero (bool): whether the Librarian received a “0 Outsiders” result
    target1 (int): position of the first player based on the info (only used if zero is False)
    target2 (int): position of the second player based on the info (only used if zero is False)
    role (str): Outsider role name received in the info (only used if zero is False)
    role_info (list): the combinations currently being tested
  Logic:
    If zero is True:
    There are exactly 0 Outsiders in play
    If zero is False:
    Either player 1 is the given Outsider role or registers as good (Spy), or
    player 2 is the given Outsider role or registers as good (Spy)

Investigator:
  Input:
    target1 (int): position of the first player based on the info
    target2 (int): position of the second player based on the info
    role (str): Minion role name got by the info
    role_info (list): the combinations currently being tested
  Logic:
    Either player 1 is the given Minion role or registers as that Minion (Spy), or
    player 2 is the given Minion role or registers as that Minion (Spy)

Chef:
  Input:
    No_pairs: The number of pairs of supposedly evil players
    role_info (list): the combinations currently being tested
  Logic:
    Start min_pairs and max_pairs at 0
    Go through each adjacent pair of players.
    If both players in the pair are evil:
    Always increase max_pairs (the pair could count).
    Increase min_pairs only if neither role can register as good (the pair must count).
    After checking all pairs, min_pairs is the guaranteed minimum and max_pairs is the possible maximum.
    Check if No_pairs is between the 2 numbers

Empath:
  Input:
    current_pos (int): position of the Empath
    no_list (list): the Empath numbers received each day (0, 1, or 2)
    role_info (list): the role combinations currently being tested
  Logic:
    For each day:
      Find the nearest alive player to the left of the Empath.
      Find the nearest alive player to the right of the Empath.
      Ignore players who died by execution or at night before that day.
      Based on the Empath number for that day:
      0: both neighbours must not be totally evil.
      1: Exactly one neighbour is evil (one not totally good, the other not totally evil).
      2: Both neighbours must not be totally good.
      Record whether the role combination satisfies that day’s Empath reading.
      Return a list of booleans indicating whether the role combination is valid for each day.
